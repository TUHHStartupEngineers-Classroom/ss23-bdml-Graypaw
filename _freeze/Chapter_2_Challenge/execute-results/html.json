{
  "hash": "a6353a6c00fba0e030b72a558c947912",
  "result": {
    "markdown": "::: {.cell hash='Chapter_2_Challenge_cache/html/unnamed-chunk-1_6b376bff91fcbb8c30667461a360f5a8'}\n\n```{.r .cell-code}\n# Standard\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.2     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.2     ✔ tibble    3.2.1\n✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n✔ purrr     1.0.1     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n:::\n\n```{.r .cell-code}\n# Modeling\nlibrary(parsnip)\n\n# Preprocessing & Sampling\nlibrary(recipes)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttache Paket: 'recipes'\n\nDas folgende Objekt ist maskiert 'package:stringr':\n\n    fixed\n\nDas folgende Objekt ist maskiert 'package:stats':\n\n    step\n```\n:::\n\n```{.r .cell-code}\nlibrary(rsample)\nlibrary(workflows)\n\n# Modeling Error Metrics\nlibrary(yardstick)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttache Paket: 'yardstick'\n\nDas folgende Objekt ist maskiert 'package:readr':\n\n    spec\n```\n:::\n\n```{.r .cell-code}\n# Plotting Decision Trees\nlibrary(rpart.plot)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLade nötiges Paket: rpart\n```\n:::\n\n```{.r .cell-code}\nbike_orderlines_tbl <- readRDS(\".\\\\..\\\\Business Decisions with Machine Learning\\\\bike_orderlines.rds\")\nbike_orderlines_tbl <- bike_orderlines_tbl %>% select(!c(total_price, quantity, order_date, order_id, order_line))\n\nsplit <- initial_split(bike_orderlines_tbl, prop = 0.7)\ntrain_data <- training(split)\ntest_data <- testing(split)\n\ndata_recipe <- recipe(price ~ ., data = train_data)\ndata_recipe <- data_recipe %>% step_scale(all_numeric_predictors())\n\nmodel_linear <- linear_reg(mode = \"regression\") %>% \n  set_engine(\"lm\")\n\nworkflow <- workflow() %>%\n  add_recipe(data_recipe) %>%\n  add_model(model_linear)\nworkflow_fit <- workflow %>% fit(data = train_data)\n\nto_predict <- \"price\"\nprediction <- predict(workflow_fit, new_data = test_data)\ntruth <- test_data[[to_predict]]\n\nrmse_value <- rmse_vec(truth, prediction$.pred)\nprint(rmse_value)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.721215e-07\n```\n:::\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}